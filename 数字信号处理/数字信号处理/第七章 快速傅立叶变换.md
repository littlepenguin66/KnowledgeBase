# 第七章 快速傅立叶变换

[快速傅里叶变换（FFT）](第七章%20快速傅立叶变换/快速傅里叶变换（FFT）.md)

### 一、引言

快速傅里叶变换（FFT）是数字信号处理领域中一种极其重要的算法，它旨在高效地计算离散傅里叶变换（DFT）。由于DFT在直接计算时，对于长度为$N$的序列，其计算复杂度为$O(N^2)$，当处理较长序列时，计算量会变得非常庞大，严重影响计算效率和实时性。而FFT算法巧妙地利用了DFT运算中的一些固有特性，如对称性、周期性等，将计算复杂度降低到$O(N\log_2 N)$，使得在实际应用中对信号进行频域分析等操作变得更加可行和高效，广泛应用于音频处理、图像处理、通信等众多领域。

### 二、DFT计算的复杂性分析

离散傅里叶变换（DFT）的定义为：对于长度为$N$的离散时间序列$x(n)$（$n = 0, 1, \cdots, N - 1$），其DFT$X(k)$为

$$
X(k)=\sum_{n = 0}^{N - 1}x(n)W_N^{kn} \quad (k = 0, 1, \cdots, N - 1)
$$

其中$W_N = e^{-j\frac{2\pi}{N}}$。

计算一个$X(k)$值需要$N$次复数乘法和$N - 1$次复数加法，而总共要计算$N$个$X(k)$值（$k = 0, 1, \cdots, N - 1$），所以直接计算DFT的复数乘法次数约为$N^2$次，复数加法次数约为$N(N - 1)$次，随着$N$的增大，计算量会迅速增长，这促使人们去寻找更高效的计算方法，也就是FFT算法。

### 三、基2 FFT算法

#### 1. 时间抽取法（Decimation in Time，DIT）

* **基本原理**：

  * 要求序列长度$N$为$2$的整数次幂，即$N = 2^M$（$M$为正整数）。其核心思想是对输入序列$x(n)$按照时间序号的奇偶性进行不断地分组和分解。
  * 首先，将原序列$x(n)$按奇偶位置分成两个子序列，偶数位置的子序列$x_1(r) = x(2r)$（$r = 0, 1, \cdots, \frac{N}{2} - 1$）和奇数位置的子序列$x_2(r) = x(2r + 1)$（$r = 0, 1, \cdots, \frac{N}{2} - 1$）。
  * 然后，可以证明原序列$x(n)$的DFT$X(k)$与这两个子序列的DFT之间存在特定的关系，即通过一定的组合运算可以由子序列的DFT得到原序列的DFT。而且对于子序列，还可以继续按照同样的奇偶分解方式进一步细分，直到子序列长度为$1$或$2$等简单情况，再利用简单的DFT计算规则（如长度为$1$的序列其DFT就是它本身，长度为$2$的序列可根据DFT定义简单计算）进行计算，最后通过层层组合还原出原序列的DFT结果。
* **蝶形运算结构**：

  * 在时间抽取法的FFT运算中，存在一种基本的运算单元叫蝶形运算，它的运算规则如下：  
    设两个复数$X_m(p)$和$X_m(q)$（$m$表示运算的级数，$p$、$q$表示不同的数据位置），经过蝶形运算后得到新的两个复数$X_{m + 1}(p)$和$X_{m + 1}(q)$，其计算公式为：

$$
\begin{cases}
X_{m + 1}(p) = X_m(p) + W_N^r X_m(q) \\
X_{m + 1}(q) = X_m(p) - W_N^r X_m(q)
\end{cases}
$$

其中$r$是与运算级数和数据位置相关的一个指数值。蝶形运算体现了FFT算法中通过巧妙的复指数运算和数据组合来减少计算量的关键所在，整个FFT的计算过程可以看作是由多个这样的蝶形运算单元按照一定的规律组合而成的。

* **计算流程与示例**：

  * 以$N = 8$为例，首先将$x(n)$（$n = 0, 1, \cdots, 7$）按奇偶分成两个长度为$4$的子序列，然后对这两个子序列继续按奇偶分解，得到四个长度为$2$的子序列，再进一步分解为八个长度为$1$的子序列。接着从最底层（长度为$1$的子序列对应的DFT计算）开始，按照蝶形运算规则逐步向上组合计算，经过三级蝶形运算（因为$N = 2^3$，共$M = 3$级），最终得到原序列$x(n)$的DFT$X(k)$（$k = 0, 1, \cdots, 7$）。

#### 2. 频率抽取法（Decimation in Frequency，DIF）

* **基本原理**：  
  同样要求序列长度$N = 2^M$，但它是从频域的角度对DFT进行分解。它首先将输入序列$x(n)$的DFT$X(k)$按频率序号的奇偶性进行分组，把整个DFT运算分成几个部分，然后分析各部分与原序列$x(n)$之间的关系，发现可以通过对原序列进行特定的处理和运算来逐步计算出不同分组下的DFT值。  
  与时间抽取法类似，对于划分后的各部分DFT计算，也可以继续细分下去，利用DFT的内在特性和复指数的规律，不断简化计算过程，直到最终得到完整的DFT结果。
* **蝶形运算结构**：  
  频率抽取法也有其对应的蝶形运算结构，虽然其具体的运算公式与时间抽取法稍有不同，但同样是通过蝶形运算这种基本单元来实现高效的计算组合，其蝶形运算也是对输入的两个复数进行特定的复指数加权相加减操作，实现数据的重新组合和DFT结果的逐步生成。
* **计算流程与示例**：  
  以$N = 8$为例，先在频域对$X(k)$按奇偶分组，然后分析这些分组与原序列$x(n)$的联系，通过逐步细分和运用蝶形运算规则进行计算。比如，先把$X(k)$分成两组，每组$4$个元素，接着对每组再细分等操作，经过三级蝶形运算，从最开始的分组逐步计算出最终完整的$X(k)$值，整个过程与时间抽取法从不同角度实现了利用DFT特性来高效计算的目的。

#### 3. 基2 FFT算法的计算复杂度分析

无论是时间抽取法还是频率抽取法的基2 FFT算法，它们都将DFT原本的$O(N^2)$计算复杂度降低到了$O(N\log_2 N)$。例如，当$N = 1024$（$2^{10}$）时，直接计算DFT的复数乘法次数约为$1024^2 = 1048576$次，而采用FFT算法，复数乘法次数约为$1024\times\log_2 1024 = 1024\times10 = 10240$次，计算量大幅减少，这使得在处理较长序列的DFT计算时，能在较短时间内完成，极大地提高了数字信号处理的效率。

### 四、其他FFT算法

#### 1. 基4 FFT算法

* **原理**：  
  基4 FFT算法适用于序列长度$N$为$4$的整数次幂的情况，即$N = 4^L$（$L$为正整数）。它将输入序列按照每$4$个元素一组进行分组和分解，通过分析每组元素与DFT结果之间的关系，利用复指数的特殊性质（$W_{4N}$等相关因子的特性）以及DFT运算的对称性等，构建起高效的计算结构。其基本运算单元相对基2 FFT会更复杂一些，但在合适的序列长度下，能进一步减少计算量，比基2 FFT算法在效率上有一定提升，尤其是对于较长且满足$4$的幂次长度的序列效果更明显。
* **特点与应用场景**：  
  基4 FFT在某些硬件实现上可能更具优势，例如一些专用的数字信号处理芯片，如果其内部结构更便于处理基于$4$为分组的运算逻辑，那么采用基4 FFT可以更好地发挥硬件性能，提高计算速度。而且在一些对计算效率要求极高、处理的数据序列长度符合要求的大规模数字信号处理应用中，如大型雷达信号处理系统等，基4 FFT算法也有应用价值。

#### 2. 分裂基FFT算法

* **原理**：  
  分裂基FFT算法结合了基2和基4 FFT的优点，它在分解序列时，根据情况灵活地采用基2和基4的分解方式。对于一部分数据按照基4的分组方式进行处理，利用基4运算的高效性，而对于剩余部分则采用基2的分解和计算，通过巧妙地混合这两种方式，在整体上进一步优化计算过程，减少计算复杂度，以达到比单纯基2或基4 FFT更好的计算效率，尤其是在各种不同长度的序列处理中，能自适应地发挥较好的性能。
* **优势与应用情况**：  
  它的优势在于对序列长度的适应性相对更强，不像基2和基4那样严格要求特定的幂次长度，在实际应用中面对各种不同长度的输入信号序列时，往往能比传统单一的FFT算法取得更好的计算效率。例如在音频和图像处理软件中，输入的数据序列长度可能是多样化的，分裂基FFT就可以根据实际长度灵活运用不同的分解策略来高效完成DFT计算，从而为后续的频谱分析、滤波等操作提供支持。

### 五、FFT算法的实现与应用考虑

#### 1. 软件实现

在通用编程语言（如C、Python等）中实现FFT算法时，需要考虑代码的效率、可读性以及对不同数据类型（如复数数据类型）的支持等。对于基2 FFT，可以按照其蝶形运算结构和计算流程，通过循环语句等方式来构建计算逻辑，并且可以利用一些优化技巧，比如减少不必要的复数运算、合理安排内存访问顺序等，提高程序的运行速度。对于更复杂的基4或分裂基FFT算法，同样要精心设计代码结构，以充分发挥其高效计算的优势。同时，很多编程语言也有现成的FFT库函数可供调用，如Python中的`numpy.fft`​模块，这些库函数通常已经经过了优化，能方便快捷地完成FFT计算，但在一些特殊应用场景下，可能还需要根据具体需求自行编写FFT算法代码。

#### 2. 硬件实现

在硬件方面，像数字信号处理器（DSP）芯片、现场可编程门阵列（FPGA）等硬件平台常用于实现FFT算法。DSP芯片具有专门的指令集和硬件结构来加速数字信号处理运算，能够高效地执行FFT算法中的复数乘法、加法以及数据存储和读取等操作，适合实时性要求较高的应用场景，如实时音频处理设备等。FPGA则可以通过编程灵活地构建FFT的运算逻辑电路，根据具体的算法（基2、基4等）和应用需求定制硬件结构，实现高速并行的FFT计算，常用于对计算速度和处理带宽要求极高的场合，比如高速通信基站中的信号处理模块等。

#### 3. FFT在信号处理中的应用

* **频谱分析**：  
  通过FFT算法快速计算信号的DFT，能得到信号的离散频谱，进而分析信号包含的频率成分、各频率分量的幅度和相位等信息。例如在音频处理中，可以分析出不同音调对应的频率及强度，判断声音的音色特点；在振动信号分析中，了解振动的频率特性以诊断机械设备的运行状态等。
* **数字滤波**：  
  在设计数字滤波器时，利用FFT先将输入信号和滤波器的冲激响应变换到频域，通过频域相乘实现滤波操作（基于DFT的循环卷积性质），再通过逆FFT变换回时域得到滤波后的输出信号。这种基于FFT的滤波方法在处理长序列信号滤波时，相比直接在时域进行卷积运算能大幅提高效率，广泛应用于通信中的信道滤波、图像滤波等领域。
* **卷积与相关运算**：  
  由于时域的卷积和相关运算可以通过DFT（借助FFT高效计算）转换为频域的乘法和其他相关运算，再变换回时域得到结果，所以在计算两个长序列的卷积（如数字信号处理中的线性滤波本质就是卷积运算）或分析两个信号的相关性（如通信中的信号同步、图像处理中的模板匹配等场景涉及的相关运算）时，FFT起到了关键的加速作用，使得这些原本计算量较大的操作能够快速完成，提高了信号处理系统的整体性能。

总之，快速傅里叶变换（FFT）作为一种高效计算DFT的算法，有着多种实现形式和广泛的应用领域，它极大地推动了数字信号处理技术的发展，为众多需要进行频域分析和相关运算的实际应用提供了强有力的计算手段。
